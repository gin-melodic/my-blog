<!-- src/components/BauhausCanvas.astro -->
<canvas id="bg-canvas" class="fixed top-0 left-0 w-full h-full -z-10"></canvas>

<script>
  import * as THREE from 'three';
  // ✨ 引入後期處理效果
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
  import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
  // ✨ 1. 引入性能監控工具
  // import Stats from 'stats.js';

  // ✨ 2. 初始化性能監控
  // const stats = new Stats();
  // stats.showPanel(0); // 0: fps, 1: ms, 2: mb
  // document.body.appendChild(stats.dom);
  // // 讓監控面板顯示在左上角
  // stats.dom.style.position = 'absolute';
  // stats.dom.style.top = '10px';
  // stats.dom.style.left = '10px';


  // 1. Scene Setup
  const scene = new THREE.Scene();
  // ✨ 添加霧效，增加深度感
  scene.fog = new THREE.Fog(0x000000, 1, 15);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;

  const canvas = document.getElementById('bg-canvas');
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
  });
  // ✨ 為了輝光效果，將背景設為純黑
  renderer.setClearColor(0x000000, 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));


  // 2. Cyberpunk Objects & Materials
  const cyberpunkColors = {
    cyan: 0x00ffff,
    magenta: 0xff00ff,
    yellow: 0xffd600,
    blue: 0x005fec,
  };

  const shapes = [];
  // ✨ 性能優化：降低幾何體複雜度
  const geometries = [
    new THREE.IcosahedronGeometry(0.8, 1), // 二十面體
    new THREE.TorusKnotGeometry(0.6, 0.15, 64, 12), // 環形結 (降低了分段)
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.SphereGeometry(0.7, 24, 12), // 球體 (降低了分段)
    new THREE.TorusGeometry(0.6, 0.25, 12, 64),   // 圓環 (降低了分段)
  ];

  // ✨ 性能優化：減少物體數量
  for (let i = 0; i < 40; i++) {
    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
    const color = new THREE.Color(Object.values(cyberpunkColors)[Math.floor(Math.random() * Object.keys(cyberpunkColors).length)]);

    // ✨ 使用不受光照影響的基礎材質，以獲得純粹的輝光線條
    const material = new THREE.MeshBasicMaterial({
      color: color,
      wireframe: true,
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    
    mesh.position.set(
      (Math.random() - 0.5) * 20,
      (Math.random() - 0.5) * 20,
      (Math.random() - 0.5) * 20
    );
    mesh.rotation.set(
      Math.random() * Math.PI,
      Math.random() * Math.PI,
      Math.random() * Math.PI
    );
    const scale = Math.random() * 0.4 + 0.2;
    mesh.scale.set(scale, scale, scale);
    
    shapes.push(mesh);
    scene.add(mesh);
  }

  // 3. ✨ 設定後期處理 (Post-Processing)
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  // 輝光效果
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.0, // strength
    0.4, // radius
    0.2  // threshold
  );
  composer.addPass(bloomPass);

  // 掃描線和膠片顆粒效果
  const filmPass = new FilmPass(
    0.35, // noise intensity
    false // grayscale
  );
  composer.addPass(filmPass);
    
  // 確保最終輸出
  const outputPass = new OutputPass();
  composer.addPass(outputPass);


  // 4. Mouse Interaction
  const mouse = new THREE.Vector2();
  window.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  });

  // 5. Animation Loop
  const clock = new THREE.Clock();
  let animationFrameId = null; // ✨ 性能優化：用於控制動畫循環

  function animate() {
    // ✨ 3. 在動畫循環開始時更新監控
    // stats.begin();

    const elapsedTime = clock.getElapsedTime();

    // ✨ 更具動感的動畫
    shapes.forEach((shape) => {
      shape.rotation.y += 0.003;
      // 讓物體緩慢向中心聚集或散開
      shape.position.z += Math.sin(elapsedTime + shape.id) * 0.01;
    });

    // ✨ 鏡頭緩慢自動旋轉，營造巡航感
    camera.position.x = Math.sin(elapsedTime * 0.1) * 2;
    camera.position.y = Math.cos(elapsedTime * 0.1) * 2;
    
    // 滑鼠互動依然保留，疊加在自動旋轉之上
    camera.position.x += (mouse.x * 2 - camera.position.x) * 0.02;
    camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.02;

    camera.lookAt(scene.position);

    // ✨ 使用 composer 進行渲染，而不是 renderer
    composer.render();
    
    // ✨ 4. 在動畫循環結束時更新監控
    // stats.end();

    // ✨ 性能優化：儲存 frame ID
    animationFrameId = requestAnimationFrame(animate);
  }

  // 6. Handle Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // ✨ 同時更新 composer 的尺寸
    composer.setSize(window.innerWidth, window.innerHeight);
  });

  // 7. ✨ 性能優化：根據頁面可見性控制動畫
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    } else {
      if (!animationFrameId) {
        animate();
      }
    }
  });

  // 初始啟動動畫
  animate();
</script>

